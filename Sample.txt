1. Big Picture: What the Framework Does
This framework is a Java–Maven–RestAssured–TestNG/JUnit based API Automation solution designed to deliver reusable, modular, and enterprise-grade test automation for REST and SOAP services.

The objectives are to:
- Standardize API testing by enforcing structure, conventions, and validations.
- Simplify request building with parameterized payloads, authentication, headers, and dynamic runtime values.
- Enable rich validation against response codes, headers, business rules, and schema compliance.
- Support multi-step workflows to simulate realistic end-to-end scenarios across multiple APIs.
- Drive tests from externalized data sources (Excel, SQL, JSON, XML, CSV).
- Provide traceability with TestRail/Jira integration for requirement-to-test mapping.
- Enable CI/CD pipelines (Jenkins, Bamboo, AWS CodeBuild) for scalable execution across environments.
- Deliver reporting via ExtentReports, Allure, and Splunk logs for debugging and stakeholder visibility.

2. Execution Lifecycle
Every execution run follows a predictable lifecycle:

1. Trigger Runner – Test execution begins via TestNG/JUnit runners or Maven goals. Suites are defined in CISuite/ XML.
2. Initialize Environment – Configurations are loaded from config.xml. These include base URLs, authentication tokens, proxy details, and global timeouts. Logging setup (log4j2.properties) and endpoint metadata (apis.json) are also initialized.
3. Prepare Request – Request builders (api/) assemble calls by injecting headers, cookies, auth schemes (OAuth2, JWT, Basic), and dynamic payloads from templates. Constants (cons/) ensure standardization.
4. Load Test Data – Test data is injected from autodata/ JSON, SQL queries in TestCaseSqlQuery/, or parsers in dataparser/. Data-driven execution ensures tests cover multiple variations.
5. Execute & Validate – RestAssured clients fire the request. Responses are validated for: HTTP status codes, headers, payloads, and schema validation.
6. Report & Publish – Results are logged into ExtentReports / Allure dashboards. Splunk logging captures request/response for debugging. CI/CD pipelines publish artifacts and push results to TestRail.

3. Deep Dive by Folder
- api/: Request builders for endpoints (per-API classes).
- cons/: Centralized constants for endpoints, default parameters.
- core/: Framework engine (clients, retry handlers, interceptors, session managers).
- dataparser/: Parsers for JSON, XML, Excel → Java POJOs.
- flow.rps/: End-to-end workflows that chain multiple APIs.
- model/: POJOs mapping request and response structures.
- test/: Test cases invoking APIs, assertions, flows.
- utils/: Common utilities for schema validation, file ops, reporting.

4. Resources (src/test/resources)
- CISuite/: TestNG XML suite definitions (smoke, regression, custom).
- jsonSchema/ & XMLSchema/: Canonical response schemas.
- autodata/: Test data JSON files.
- templates/: Freemarker/JSON payload templates for dynamic requests.
- TestCaseSqlQuery/: SQL queries for DB-driven validations.
- apis.json: API endpoint metadata (base path, versions, parameters).
- config.xml: Environment-specific configuration.
- TestRailSectionMapping.properties: TestRail integration mapping.
- log4j2.properties: Logging setup (console/file/Splunk).

5. Example Test Flow
Case: Create User API
1. UserRequest POJO created with name, email, role.
2. UserApiBuilder prepares request (headers, token, body).
3. RestAssured fires POST /user.
4. Response validated → status = 201, schema matches UserResponseSchema.json.
5. ExtentReport logs → Splunk dashboard updated.

6. Adding a New API Test
Steps for onboarding a new endpoint:
1. Add endpoint in cons/Endpoints.java or apis.json.
2. Create request/response models under model/.
3. Implement request builder under api/.
4. Place schema files in jsonSchema/ or XMLSchema/.
5. Prepare data in autodata/ or SQL.
6. Write test logic in test/.
7. Add test to CISuite/.

7. CI/CD & Reporting
- Pipeline Integration: Jenkins, Bamboo, AWS CodeBuild/CodePipeline.
- Execution Levels: Smoke (quick), Regression (full), Integration (cross-service).
- Reports: ExtentReports (HTML dashboards), Allure Reports (trend graphs), Splunk integration.
- TestRail/Jira: Automatic push of execution status → requirements traceability.

8. Conventions & Best Practices
- Naming:
   * Test → VerbResourceTest (UploadFileTest).
   * API Builder → ResourceApi.
   * Models → ResourceRequest / ResourceResponse.

- Standards:
   * One API class per resource.
   * One schema file per response type.
   * Flows = business process simulation.
   * Expressive assertion wrappers (thenStatusIs, thenBodyContains).

- Governance:
   * Peer review of new API builders.
   * Schema versioning (v1, v2).
   * Backward compatibility checks.

9. Error Handling & Recovery
- Retry mechanism for transient failures (timeouts, 502/503).
- Graceful handling of auth/token expiry (auto-refresh).
- Circuit breaker logic for repeated downstream failures.
- Custom exception classes for better traceability.

10. Quick Start
# Run all tests
mvn clean test

# Run smoke suite
mvn -DsuiteXmlFile=src/test/resources/CISuite/smoke.xml test

# Run regression suite
mvn -DsuiteXmlFile=src/test/resources/CISuite/regression.xml test

# Run group-based
mvn test -Dgroups="sanity"

11. Extensibility
- Multi-protocol support: REST, SOAP, gRPC.
- Data layer expansion: MongoDB, Kafka, Redis validations.
- Pluggable auth: Extendable to SAML, Kerberos.
- Parallel execution: TestNG XML parallel configs + Maven Surefire plugin.

12. Future Enhancements
- AI-driven test data generation.
- API fuzz testing integration.
- Contract testing with PactFlow.
- Containerized execution with Docker/Selenium Grid for scale.

